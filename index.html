<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>çµå¢ƒå¡”ç½—</title>

    <link rel="stylesheet" href="style.css">
    <script src="https://npm.elemecdn.com/marked/marked.min.js"></script>
    
    <style>
        /* ======= â¬‡ï¸ è¯·æŠŠè¿™æ®µè¡¥ä¸å¤åˆ¶åˆ° <style> é‡Œé¢ â¬‡ï¸ ======= */

    /* 1. ä¿®å¤é¦–é¡µæ ‡é¢˜ (å¼ºåˆ¶å–æ¶ˆé€æ˜æ¸å˜ï¼Œæ”¹ä¸ºé‡‘è‰²å®å¿ƒ) */
    h1 { 
        color: #fbbf24 !important; 
        -webkit-text-fill-color: #ffdd88 !important; 
        background: none !important; 
        text-shadow: 0 0 20px rgba(253, 196, 51, 0.4);
    }

    /* 2. ä¿®å¤æŠ½å¡ç»“æœæ–‡å­— (å¼ºåˆ¶å®šä¹‰æ­£é€†ä½é¢œè‰²) */
    /* ç‰Œåé¢œè‰² */
    #label-name-0, #label-name-1, #label-name-2 { 
        color: #fef3c7 !important; /* æµ…é»„è‰² */
        font-size: 14px !important;
        margin-bottom: 4px !important;
    }
    
    /* æ­£ä½æ ‡ç­¾æ ·å¼ */
    .text-yellow-300 { 
        color: #fcd34d !important; 
        border: 1px solid #713f12 !important; 
        background-color: rgba(0,0,0,0.6) !important;
    }
    
    /* é€†ä½æ ‡ç­¾æ ·å¼ */
    .text-red-300 { 
        color: #fca5a5 !important; 
        border: 1px solid #7f1d1d !important;
        background-color: rgba(0,0,0,0.6) !important;
    }
    
    /* åº•éƒ¨ SLOT æ ‡ç­¾é¢œè‰² (PAST/PRESENT/FUTURE) */
    .slot-label {
        color: #d8b4fe !important;
        font-weight: bold !important;
    }

    /* ======= â¬†ï¸ è¡¥ä¸ç»“æŸ â¬†ï¸ ======= */

        body { margin: 0; overflow: hidden; background-color: #0a0a12; font-family: 'Noto Serif SC', serif; user-select: none; touch-action: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #start-screen {
            background: radial-gradient(circle at center, rgba(20, 10, 40, 0.95) 0%, #000 100%);
            transition: opacity 0.8s ease-in-out;
            z-index: 100;
        }
        
        #main-ui { display: none; opacity: 0; transition: opacity 0.8s ease-in-out; }
        .ui-layer { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 10; }
        .glass { 
            background: rgba(10, 10, 25, 0.85); 
            backdrop-filter: blur(16px); 
            border: 1px solid rgba(255,255,255,0.15); 
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        }
        
        .camera-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 100px; height: 75px; 
            border-radius: 8px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 20; background: #000;
            transform: scaleX(-1);
            pointer-events: auto; opacity: 0.8; transition: opacity 0.3s;
            display: none; 
        }
        .camera-preview:hover { opacity: 1; }

        #cursor {
            position: absolute; width: 30px; height: 30px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%; pointer-events: none; z-index: 100;
            transform: translate(-50%, -50%); display: none;
            transition: width 0.1s, height 0.1s, border-color 0.1s;
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        #cursor.mode-open { border-color: #fff; width: 30px; height: 30px; background: transparent; } 
        #cursor.mode-point { border-color: #fbbf24; background: rgba(251, 191, 36, 0.2); width: 12px; height: 12px; } 
        #cursor.mode-pinch { border-color: #a855f7; width: 20px; height: 20px; }
        #cursor.mode-fist { border-color: #ef4444; background: #ef4444; width: 40px; height: 40px; box-shadow: 0 0 25px rgba(239, 68, 68, 0.6); } 

        .gesture-tag {
            position: absolute; top: -25px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.9); font-size: 10px; white-space: nowrap; 
            text-shadow: 0 2px 4px black; font-weight: bold; letter-spacing: 1px;
        }

        #interpretation-panel {
            transition: all 0.5s ease;
            opacity: 0; transform: translateY(-20px);
        }
        #interpretation-panel.visible {
            opacity: 1; transform: translateY(0);
        }

        /* æ‰‹æœºç«¯æ ·å¼ (åŠ å¤§å°ºå¯¸) */
        .card-slot {
            /* åŸæ¥æ˜¯ 18vw / 30vwï¼Œæ”¹å¤§åˆ° 24vw / 40vw */
            width: 24vw; 
            height: 40vw; 
            
            /* åŸæ¥é™åˆ¶äº† 70px/118pxï¼Œè¿™å¤ªå°äº†ï¼Œä¼šå¯¼è‡´å¤§å±æ‰‹æœºæ¡†ä¸ä½ï¼Œå»ºè®®æ”¹å¤§æˆ–ç›´æ¥å»æ‰ */
            max-width: 110px; 
            max-height: 185px; 
            
            /* ä¿æŒè¾¹æ¡†å’Œé€æ˜èƒŒæ™¯ */
            border: 1px dashed rgba(168, 85, 247, 0.5); /* è¾¹æ¡†é¢œè‰²ç¨å¾®åŠ æ·±ä¸€ç‚¹ï¼Œçœ‹å¾—æ›´æ¸… */
            border-radius: 8px;
            background: transparent; 
            
            display: flex; align-items: center; justify-content: center;
            transition: border-color 0.3s, width 0.3s, height 0.3s;
            position: relative;
        }
        
        /* ç”µè„‘/å¹³æ¿ç«¯æ ·å¼ (åŠ å¤§å°ºå¯¸) */
        @media (min-width: 768px) {
            .card-slot { 
                /* åŸæ¥æ˜¯ 100px/170pxï¼Œæ”¹ä¸º 140px / 240px ä»¥åŒ¹é…ç”µè„‘å±å¹•ä¸Šçš„å¡ç‰‡ */
                width: 140px; 
                height: 240px; 
                max-width: none; 
                max-height: none; 
            } 
            .slot-label { font-size: 14px; }
        }
        
        /* .card-slot {
            width: 18vw; height: 30vw; 
            max-width: 70px; max-height: 118px;
            border: 1px dashed rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            background: transparent;

            display: flex; align-items: center; justify-content: center;
            transition: border-color 0.3s;
            position: relative;

        } */
        
        .slot-label { font-size: 10px; opacity: 0.5; letter-spacing: 1px; }
        
        @media (min-width: 768px) {
            .card-slot { width: 100px; height: 170px; max-width: none; max-height: none; } 
            .slot-label { font-size: 12px; }
        }
        
        .info-text { font-size: 10px; }
        @media (min-width: 768px) { .info-text { font-size: 12px; } }

        .pulse-text { animation: pulse-opacity 2s infinite; }
        @keyframes pulse-opacity { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        #ai-modal, #settings-modal {
            backdrop-filter: blur(20px);
        }
        .markdown-body { color: #e2e8f0; font-size: 0.9rem; line-height: 1.6; }
        .markdown-body h3 { color: #fbbf24; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; font-size: 1.1rem; }
        .markdown-body strong { color: #a855f7; }
        .markdown-body ul { list-style-type: disc; padding-left: 1.5em; margin-bottom: 1em; }

        #error-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            background: #ef4444; color: white; text-align: center;
            padding: 8px; z-index: 1000; font-size: 12px; display: none;
        }
    </style>

    <!-- ä¾èµ–åº“ -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    
    <div id="error-bar"></div>
    <div id="canvas-container"></div>
    <div id="cursor"><div id="cursor-text" class="gesture-tag">Waiting...</div></div>
    <video class="input_video" style="display:none"></video>
    <canvas class="camera-preview" id="output_canvas"></canvas>

    <!-- å¯åŠ¨å±å¹• -->
    <div id="start-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center transition-opacity duration-1000">
        <div class="glass p-8 rounded-2xl text-center max-w-md w-full mx-4 border border-purple-500/30 shadow-2xl">
            <div class="mb-6">
                <h1 class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-300 via-yellow-200 to-purple-300 mb-2 font-serif tracking-widest">çµå¢ƒå¡”ç½—</h1>
                <p class="text-purple-300/60 text-xs tracking-[0.3em]">CONNECTING TO THE ASTRAL PLANE</p>
            </div>
            
            <div class="mb-8 relative group">
                <label for="question-input" class="block text-left text-xs text-yellow-500/80 mb-2 font-mono">å¿ƒä¸­çš„ç–‘æƒ‘ (QUESTION):</label>
                <input type="text" id="question-input" placeholder="ä¾‹å¦‚ï¼šæˆ‘æœ€è¿‘çš„è¿åŠ¿å¦‚ä½•ï¼Ÿ" 
                    class="w-full bg-black/40 border border-purple-500/30 rounded-lg py-4 px-4 text-center text-yellow-100 placeholder-purple-400/30 focus:outline-none focus:border-yellow-400/60 focus:bg-black/60 transition-all font-serif text-lg">
            </div>

            <button id="start-btn" class="w-full py-4 bg-gradient-to-r from-purple-900/80 to-indigo-900/80 hover:from-purple-800 hover:to-indigo-800 border border-purple-500/50 text-yellow-100 font-bold tracking-[0.2em] rounded-lg shadow-[0_0_20px_rgba(168,85,247,0.2)] hover:shadow-[0_0_30px_rgba(168,85,247,0.4)] transition-all duration-300 transform hover:-translate-y-1">
                å¼€å¯å‘½è¿ä¹‹é—¨
            </button>
        </div>
    </div>

    <!-- AI å¼¹çª— -->
    <div id="ai-modal" class="fixed inset-0 bg-black/80 z-50 hidden flex-col items-center justify-center p-4">
        <div class="glass w-full max-w-2xl max-h-[80vh] rounded-2xl flex flex-col relative overflow-hidden border border-purple-500/30">
            <div class="p-4 border-b border-white/10 flex justify-between items-center bg-purple-900/20">
                <div class="flex items-center"><span class="text-2xl mr-2">ğŸ”®</span><h3 class="text-xl font-bold text-yellow-100 font-serif">ç‰Œé¢è§£è¯»</h3></div>
                <button id="close-ai-btn" class="text-gray-400 hover:text-white transition">âœ•</button>
            </div>
            <div id="ai-content" class="p-6 overflow-y-auto markdown-body scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-transparent"></div>
            <div class="p-4 border-t border-white/10 flex justify-end bg-black/20">
                <button id="close-ai-btn-2" class="px-4 py-2 text-sm text-gray-300 hover:text-white transition">å…³é—­</button>
            </div>
        </div>
    </div>

    <!-- è®¾ç½®å¼¹çª— -->
    <div id="settings-modal" class="fixed inset-0 bg-black/80 z-50 hidden flex-col items-center justify-center p-4">
        <div class="glass w-full max-w-md rounded-xl p-6 border border-white/10">
            <h3 class="text-lg font-bold text-white mb-4"âš™ï¸ ç³»ç»Ÿè®¾ç½® (SiliconFlow)</h3>
            <div class="mb-4 space-y-3">
                <div>
                    <label class="block text-xs text-gray-400 mb-1">API Key (sk-...)</label>
                    <input type="password" id="api-key-input" placeholder="è¯·è¾“å…¥ SiliconFlow API Key" class="w-full bg-black/50 border border-gray-600 rounded p-2 text-white text-sm focus:border-purple-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-1">API åœ°å€</label>
                    <input type="text" id="api-url-input" value="https://api.siliconflow.cn/v1" class="w-full bg-black/50 border border-gray-600 rounded p-2 text-white text-sm focus:border-purple-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-1">æ¨¡å‹åç§°</label>
                    <input type="text" id="api-model-input" value="deepseek-ai/DeepSeek-V3" class="w-full bg-black/50 border border-gray-600 rounded p-2 text-white text-sm focus:border-purple-500 focus:outline-none">
                </div>
                <p class="text-[10px] text-gray-500">Key ä»…ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ã€‚</p>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="save-settings-btn" class="bg-purple-600 hover:bg-purple-500 text-white px-4 py-2 rounded text-sm transition">ä¿å­˜</button>
                <button id="cancel-settings-btn" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded text-sm transition">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="main-ui" class="ui-layer flex flex-col justify-between p-6">
        <div class="flex justify-between items-start pointer-events-auto w-full max-w-6xl mx-auto relative">
            <div class="glass px-6 py-4 rounded-xl text-white flex flex-col items-start min-w-[280px] z-10 transition-all duration-300 hover:bg-opacity-90">
                <h1 class="text-xl font-bold text-purple-300 tracking-[0.2em] font-serif border-b border-purple-500/30 pb-2 mb-2 w-full">TRINITY TAROT</h1>
                <div id="status-container" class="space-y-1 w-full">
                    <div class="text-[10px] text-gray-400 mb-1 flex items-center">
                        <span class="w-1.5 h-1.5 bg-yellow-500 rounded-full mr-2"></span>
                        <span id="user-question-display" class="truncate max-w-[200px] italic">...</span>
                    </div>
                    <p id="phase-title" class="text-sm font-bold text-yellow-100">å‡†å¤‡ä¸­...</p>
                    <p id="gesture-instruction" class="text-xs text-green-300 font-medium pulse-text flex items-center">
                        <span class="mr-2 text-base">ğŸ–</span> å¼ å¼€æ‰‹æŒ Â· å·¦å³æŒ¥åŠ¨æµè§ˆ
                    </p>
                </div>
            </div>

            <div class="flex flex-wrap justify-end gap-2 z-10 w-1/2 md:w-auto">
                <button id="settings-btn" class="glass px-3 py-2 text-gray-300 hover:text-white rounded transition shadow-lg" title="è®¾ç½® API">âš™ï¸</button>
                <label id="btn-import" class="glass px-4 py-2 text-xs text-blue-300 hover:bg-blue-900/40 rounded transition cursor-pointer flex items-center shadow-lg" title="é€‰æ‹©æœ¬åœ°å›¾ç‰‡">
                    <span class="mr-1">ğŸ“‚</span> <span class="hidden md:inline">å¯¼å…¥</span>
                    <input type="file" id="upload-input" multiple accept="image/*" style="display:none">
                </label>
                <button id="export-btn" class="glass px-4 py-2 text-xs text-yellow-300 hover:bg-yellow-900/40 rounded transition hidden flex items-center shadow-lg border border-yellow-500/50"><span class="mr-1">ğŸ’¾</span> <span class="hidden md:inline">å¯¼å‡º</span></button>
                <button id="cam-btn" class="glass px-4 py-2 text-xs text-green-300 hover:bg-green-900/40 rounded transition shadow-lg">ğŸ“· <span class="hidden md:inline">æ‘„åƒå¤´</span></button>
                <button id="reset-btn" class="glass px-4 py-2 text-xs text-indigo-300 hover:bg-indigo-900/40 rounded transition hidden shadow-lg flex items-center"><span class="mr-1">ğŸƒ</span> é‡æ–°æŠ½å¡</button>
                <button id="change-q-btn" class="glass px-4 py-2 text-xs text-orange-300 hover:bg-orange-900/40 rounded transition hidden shadow-lg flex items-center"><span class="mr-1">ğŸ”„</span> æ¢ä¸ªé—®é¢˜</button>
            </div>
        </div>

        <div id="interpretation-panel" class="glass px-8 py-5 rounded-xl text-center max-w-lg absolute left-1/2 transform -translate-x-1/2 top-28 pointer-events-none z-0">
            <h2 id="interp-name" class="text-2xl font-bold text-yellow-100 mb-2 font-serif"></h2>
            <div class="w-12 h-0.5 bg-purple-500 mx-auto mb-3"></div>
            <p id="interp-desc" class="text-sm text-gray-200 leading-relaxed"></p>
        </div>

        <div class="absolute bottom-4 left-0 w-full flex flex-col items-center pointer-events-none z-0">
            <button id="ai-btn" class="mb-6 pointer-events-auto hidden transform transition-all duration-500 hover:scale-105 group relative">
                <div class="absolute inset-0 bg-gradient-to-r from-purple-600 to-blue-600 rounded-full blur opacity-75 group-hover:opacity-100 transition duration-1000 group-hover:duration-200 animate-tilt"></div>
                <div class="relative px-8 py-3 bg-black rounded-full leading-none flex items-center space-x-2 border border-purple-500/50">
                    <span class="text-2xl">ğŸ”®</span><span class="text-purple-100 font-bold tracking-widest">ç‚¹å‡»è¿›è¡Œç‰Œé¢è§£è¯»</span>
                </div>
            </button>

            <div id="slots-container" class="flex justify-center space-x-2 md:space-x-8 w-full px-2">
                <div class="flex flex-col items-center">
                    <div class="card-slot" id="slot-0"><span class="text-purple-500 text-xs font-bold tracking-widest slot-label">PAST</span></div>
                    <div class="mt-2 text-center transition-opacity duration-500 opacity-0" id="info-0">
                        <div class="text-yellow-100 font-bold info-text" id="label-name-0"></div>
                        <div class="text-gray-400 mt-0.5 px-2 py-0 rounded bg-black/60 inline-block info-text" id="label-orient-0"></div>
                    </div>
                </div>
                <div class="flex flex-col items-center">
                    <div class="card-slot" id="slot-1"><span class="text-purple-500 text-xs font-bold tracking-widest slot-label">PRESENT</span></div>
                    <div class="mt-2 text-center transition-opacity duration-500 opacity-0" id="info-1">
                        <div class="text-yellow-100 font-bold info-text" id="label-name-1"></div>
                        <div class="text-gray-400 mt-0.5 px-2 py-0 rounded bg-black/60 inline-block info-text" id="label-orient-1"></div>
                    </div>
                </div>
                <div class="flex flex-col items-center">
                    <div class="card-slot" id="slot-2"><span class="text-purple-500 text-xs font-bold tracking-widest slot-label">FUTURE</span></div>
                    <div class="mt-2 text-center transition-opacity duration-500 opacity-0" id="info-2">
                        <div class="text-yellow-100 font-bold info-text" id="label-name-2"></div>
                        <div class="text-gray-400 mt-0.5 px-2 py-0 rounded bg-black/60 inline-block info-text" id="label-orient-2"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- å…¨å±€é”™è¯¯æ•è· ---
        window.onerror = function(msg, url, line) {
            const bar = document.getElementById('error-bar');
            if(bar) {
                bar.style.display = 'block';
                bar.innerText = `âš ï¸ é”™è¯¯: ${msg} (è¡Œå·: ${line})`;
            }
            return false;
        };

        // --- 1. æ ¸å¿ƒå®šä¹‰ ---
        const EMBEDDED_IMAGES = {};
        // å…³é”®ä¿®æ”¹ï¼šå°† baseUrl æ”¹ä¸ºç›¸å¯¹è·¯å¾„ "images/card/"
        const textureCache = new Map(); // ç”¨æ¥å­˜å·²ç»åŠ è½½å¥½çš„å›¾ç‰‡
        const IMG_CONFIG = { baseUrl: "images/card/", suffix: ".jpg" };
        const CONFIG = { cardCount: 78, cardW: 2.2, cardH: 3.8, archRadius: 40, archY: -39, angleStep: 0.06, scrollSpeed: 0.02, dragInertia: 0.95, camZ: 14, slotScale: 0.8 };
        const PHASES = ["è¿‡å» (Past)", "ç°åœ¨ (Present)", "æœªæ¥ (Future)"];
        const MAX_CARDS = 3;
        const DEFAULT_API_KEY = "sk-rpsahpqrddtjcdtkwleekynjvmlqalstfuhyouidpwpcyxkw";

        let scene, camera, renderer, raycaster;
        let deckGroup = new THREE.Group(); 
        let stars;
        let currentAngle = 0, scrollVelocity = 0;
        let handPos = new THREE.Vector2(0.5, 0.5);
        let gesture = 'NONE';
        let hoveredCard = null; 
        let animationQueue = []; 
        let drawnCards = []; 
        let cardBackTexture;
        let customImages = [];
        let userQuestion = "";
        let isGameActive = false;
        
        let isDragging = false;
        let pointerStartX = 0;
        let pointerStartTime = 0;
        let cameraStream = null;

        // --- 2. åŸºç¡€è¾…åŠ©å‡½æ•° ---

        function translateRank(r) { 
            const map = { 'Ace': 'ACE', 'Two':'2', 'Three':'3', 'Four':'4', 'Five':'5', 'Six':'6', 'Seven':'7', 'Eight':'8', 'Nine':'9', 'Ten':'10', 'Page': 'ä¾ä»', 'Knight': 'éª‘å£«', 'Queen': 'ç‹å', 'King': 'å›½ç‹' }; 
            return map[r] || r; 
        }

        function createBackPattern() {
            const c = document.createElement('canvas'); c.width=256; c.height=512;
            const ctx=c.getContext('2d'); 
            ctx.fillStyle='#2e1065'; ctx.fillRect(0,0,256,512);
            ctx.strokeStyle='#d8b4fe'; ctx.lineWidth=2; 
            ctx.beginPath(); for(let i=0;i<512;i+=32){ctx.moveTo(0,i);ctx.lineTo(128,i+64);ctx.lineTo(256,i);ctx.moveTo(0,i);ctx.lineTo(128,i-64);ctx.lineTo(256,i);} ctx.stroke(); 
            ctx.strokeStyle='#fbbf24'; ctx.lineWidth=8; ctx.strokeRect(4,4,248,504);
            ctx.fillStyle='#172554'; ctx.beginPath(); ctx.arc(128,256,60,0,Math.PI*2); ctx.fill();
            ctx.strokeStyle='#fbbf24'; ctx.lineWidth=3; ctx.stroke();
            ctx.fillStyle='#fbbf24'; ctx.font='40px serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('â‚', 128, 256);
            const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
        }

        function createFacePattern(d) {
            const c = document.createElement('canvas'); c.width=512; c.height=880;
            const ctx=c.getContext('2d'); 
            ctx.fillStyle='#fef3c7'; ctx.fillRect(0,0,512,880);
            ctx.strokeStyle='#000'; ctx.lineWidth=4; ctx.strokeRect(20,20,472,840);
            ctx.fillStyle='#111'; ctx.font='bold 50px "Noto Serif SC"'; ctx.textAlign='center'; ctx.fillText(d.cn, 256, 100);
            ctx.font='italic 30px serif'; ctx.fillStyle='#555'; ctx.fillText(d.en, 256, 150);
            ctx.fillStyle= d.type==='major' ? '#581c87' : '#1e40af'; ctx.fillRect(80, 200, 352, 450);
            ctx.fillStyle='#fff'; ctx.font='120px serif'; ctx.fillText(d.type==='major' ? 'â‚' : 'âš”', 256, 450);
            const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
        }

        function generateDeckData() {
            let id=0; const list=[];
            
            // å…³é”®ä¿®æ”¹ï¼šå¤§é˜¿å¡çº³å‘½åè§„åˆ™ - è‡ªåŠ¨æ·»åŠ  "00", "01" ç­‰å‰ç¼€
            const majors=[{en:"The Fool",cn:"æ„šè€…",desc:"æ–°çš„å¼€å§‹ï¼Œæ— é™æ½œåŠ›"},{en:"The Magician",cn:"é­”æœ¯å¸ˆ",desc:"åˆ›é€ åŠ›ï¼Œè¡ŒåŠ¨åŠ›"},{en:"The High Priestess",cn:"å¥³ç¥­å¸",desc:"ç›´è§‰ï¼Œæ½œæ„è¯†"},{en:"The Empress",cn:"çš‡å",desc:"ä¸°é¥¶ï¼Œæ¯æ€§"},{en:"The Emperor",cn:"çš‡å¸",desc:"æƒå¨ï¼Œç»“æ„"},{en:"The Hierophant",cn:"æ•™çš‡",desc:"ä¼ ç»Ÿï¼Œä¿¡ä»°"},{en:"The Lovers",cn:"æ‹äºº",desc:"çˆ±ï¼Œå’Œè°"},{en:"The Chariot",cn:"æˆ˜è½¦",desc:"æ„å¿—åŠ›ï¼Œèƒœåˆ©"},{en:"Strength",cn:"åŠ›é‡",desc:"å‹‡æ°”ï¼Œè€å¿ƒ"},{en:"The Hermit",cn:"éšå£«",desc:"å†…çœï¼ŒæŒ‡å¼•"},{en:"Wheel of Fortune",cn:"å‘½è¿ä¹‹è½®",desc:"å¥½è¿ï¼Œè½¬æŠ˜ç‚¹"},{en:"Justice",cn:"æ­£ä¹‰",desc:"å…¬å¹³ï¼Œå› æœ"},{en:"The Hanged Man",cn:"å€’åŠäºº",desc:"ç‰ºç‰²ï¼Œæ–°è§†è§’"},{en:"Death",cn:"æ­»ç¥",desc:"ç»“æŸï¼Œé‡ç”Ÿ"},{en:"Temperance",cn:"èŠ‚åˆ¶",desc:"å¹³è¡¡ï¼Œé€‚åº¦"},{en:"The Devil",cn:"æ¶é­”",desc:"æŸç¼šï¼Œé˜´æš—é¢"},{en:"The Tower",cn:"é«˜å¡”",desc:"çªå˜ï¼Œå¯ç¤º"},{en:"The Star",cn:"æ˜Ÿæ˜Ÿ",desc:"å¸Œæœ›ï¼Œçµæ„Ÿ"},{en:"The Moon",cn:"æœˆäº®",desc:"å¹»è§‰ï¼Œæ½œæ„è¯†"},{en:"The Sun",cn:"å¤ªé˜³",desc:"å¿«ä¹ï¼ŒæˆåŠŸ"},{en:"Judgement",cn:"å®¡åˆ¤",desc:"è§‰é†’ï¼Œå¬å”¤"},{en:"The World",cn:"ä¸–ç•Œ",desc:"å®Œæˆï¼Œæ•´åˆ"}];
            
            majors.forEach((m, index) => {
                // å°†ç´¢å¼•è½¬ä¸ºä¸¤ä½æ•°å­—ç¬¦ä¸² (ä¾‹å¦‚ 0 -> "00", 5 -> "05")
                const numPrefix = index.toString().padStart(2, '0');
                const fileName = `${numPrefix}${m.cn}.jpg`; // ç»“æœå¦‚ "00æ„šè€….jpg"
                list.push({...m, type:'major', id:id++, file: fileName});
            });

            // å…³é”®ä¿®æ”¹ï¼šå°é˜¿å¡çº³å‘½åè§„åˆ™ - ä½¿ç”¨ "èŠ±è‰²+æ•°å­—/åç§°.jpg"
            const suits=[{n:'Wands',c:'æƒæ–',p:'wa',m:'è¡ŒåŠ¨'},{n:'Cups',c:'åœ£æ¯',p:'cu',m:'æƒ…æ„Ÿ'},{n:'Swords',c:'å®å‰‘',p:'sw',m:'æ€æƒ³'},{n:'Pentacles',c:'æ˜Ÿå¸',p:'pe',m:'ç‰©è´¨'}];
            const ranks=['Ace','Two','Three','Four','Five','Six','Seven','Eight','Nine','Ten','Page','Knight','Queen','King'];
            
            // å»ºç«‹æ–‡ä»¶åä¸“ç”¨çš„æ•°å­—/åç§°æ˜ å°„ (Ace->1, Two->2... Page->ä¾ä»)
            const fileRankMap = {
                'Ace': 'ACE', 'Two': '2', 'Three': '3', 'Four': '4', 'Five': '5',
                'Six': '6', 'Seven': '7', 'Eight': '8', 'Nine': '9', 'Ten': '10',
                'Page': 'ä¾å«', 'Knight': 'éª‘å£«', 'Queen': 'ç‹å', 'King': 'å›½ç‹'
            };

            suits.forEach(s=>{
                ranks.forEach((r)=>{
                    const displayRank = translateRank(r); // æ˜¾ç¤ºç”¨ï¼Œä¾‹å¦‚ "é¦–ç‰Œ"
                    const fileRank = fileRankMap[r];      // æ–‡ä»¶åç”¨ï¼Œä¾‹å¦‚ "1"
                    // æ–‡ä»¶åç”Ÿæˆï¼šå®å‰‘2.jpg, æƒæ–1.jpg, åœ£æ¯å›½ç‹.jpg
                    const fileName = `${s.c}${fileRank}.jpg`;
                    
                    list.push({
                        en: `${r} of ${s.n}`,
                        cn: `${s.c} ${displayRank}`,
                        desc: `${s.m}ä¹‹${displayRank}`,
                        type: 'minor',
                        file: fileName,
                        id: id++
                    });
                })
            });
            return list;
        }
        // --- âœ¨ æ–°å¢ï¼šæ´—ç‰Œç®—æ³• (Fisher-Yates Shuffle) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                // äº¤æ¢ä½ç½®
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        // --- âœ¨ æ–°å¢ï¼šåå°é™é»˜é¢„åŠ è½½æ‰€æœ‰å¡ç‰Œ âœ¨ ---
        function preloadAllImages() {
            console.log("å¼€å§‹åå°é¢„åŠ è½½æ‰€æœ‰å¡ç‰Œ...");
            const loader = new THREE.TextureLoader();
            
            // éå† 78 å¼ ç‰Œçš„æ•°æ®
            DECK_DATA.forEach(data => {
                const url = IMG_CONFIG.baseUrl + data.file;
                
                // å¦‚æœç¼“å­˜é‡Œæ²¡æœ‰ï¼Œå°±å¼€å§‹åŠ è½½
                if (!textureCache.has(data.file)) {
                    loader.load(
                        url,
                        (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            tex.name = 'loaded_image';
                            // åŠ è½½æˆåŠŸåï¼Œå­˜å…¥ç¼“å­˜
                            textureCache.set(data.file, tex);
                        },
                        undefined,
                        (err) => {
                            // å³ä½¿å¤±è´¥ä¹Ÿä¸æŠ¥é”™ï¼Œé™é»˜å¤„ç†
                            // console.log(`é¢„åŠ è½½å¤±è´¥: ${data.file}`);
                        }
                    );
                }
            });
        }
        const DECK_DATA = generateDeckData();

        function createStars() { const geo = new THREE.BufferGeometry(); const pos = []; for(let i=0; i<2000; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*50 - 20); geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); const mat = new THREE.PointsMaterial({color:0xffffff, size:0.04, transparent:true, opacity:0.8}); stars = new THREE.Points(geo, mat); scene.add(stars); }
        function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function getSlotWorldPosition(slotIndex) {
            const slotEl = document.getElementById(`slot-${slotIndex}`);
            if (!slotEl) return new THREE.Vector3(0, -4, 0);
            const rect = slotEl.getBoundingClientRect();
            const x = ((rect.left + rect.width / 2) / window.innerWidth) * 2 - 1;
            const y = -((rect.top + rect.height / 2) / window.innerHeight) * 2 + 1;
            const ndc = new THREE.Vector3(x, y, 0.5);
            ndc.unproject(camera);
            const dir = ndc.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z; 
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            return pos;
        }

        function updateCursorStyle(type) {
            const cursor = document.getElementById('cursor');
            const text = document.getElementById('cursor-text');
            if(!cursor) return;
            cursor.className = ''; 
            if (type === 'POINTER') {
                cursor.style.display = 'block';
                if (hoveredCard) {
                    cursor.classList.add('mode-point'); text.innerText = "ç‚¹å‡»";
                } else {
                    cursor.classList.add('mode-open'); text.innerText = "æ»‘åŠ¨";
                }
            } else if (type === 'GESTURE') {
                cursor.style.display = 'block';
                if (gesture === 'OPEN') { cursor.classList.add('mode-open'); text.innerText = "æµè§ˆ"; }
                else if (gesture === 'POINT') { cursor.classList.add('mode-point'); text.innerText = "ç„å‡†"; }
                else if (gesture === 'PINCH') { cursor.classList.add('mode-pinch'); text.innerText = "æ¾å¼€"; }
                else if (gesture === 'FIST') { cursor.classList.add('mode-fist'); text.innerText = "æŠ½å–"; }
            }
        }
        function ensureCardTexture(card) {
            const data = card.userData.data;
            const frontMesh = card.children[1]; 
            
            // 1. å¦‚æœå·²ç»åŠ è½½è¿‡ï¼Œç›´æ¥è¿”å›
            if (frontMesh.material.map && frontMesh.material.map.name === 'loaded_image') return;
            
            // 2. æ£€æŸ¥ç¼“å­˜
            if (typeof textureCache !== 'undefined' && textureCache.has(data.file)) {
                frontMesh.material.map = textureCache.get(data.file);
                
                // âœ¨âœ¨âœ¨ã€å…³é”®ä¿®æ”¹ 1ã€‘âœ¨âœ¨âœ¨
                // æŠŠæè´¨é¢œè‰²è®¾ä¸ºçº¯ç™½ï¼Œå¦åˆ™å›¾ç‰‡ä¼šå‘é»‘ï¼
                frontMesh.material.color.set(0xffffff);
                
                frontMesh.material.needsUpdate = true;
                return;
            }

            // 3. é»˜è®¤æ–‡å­—å›¾æ¡ˆï¼ˆè¿™é‡Œä¸éœ€è¦æ”¹ç™½ï¼Œä¿æŒåŸæ¥çš„æ·±è‰²èƒŒæ™¯ï¼‰
            if (!frontMesh.material.map || frontMesh.material.map.name !== 'fallback') {
                const fallbackTex = createFacePattern(data); 
                fallbackTex.name = 'fallback';
                frontMesh.material.map = fallbackTex;
                frontMesh.material.needsUpdate = true;
            }
            
            // 4. ç½‘ç»œåŠ è½½
            let useUrl = IMG_CONFIG.baseUrl + data.file; 
            const loader = new THREE.TextureLoader();
            loader.load(
                useUrl, 
                (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    tex.name = 'loaded_image';
                    
                    if (typeof textureCache !== 'undefined') {
                        textureCache.set(data.file, tex);
                    }
                    
                    frontMesh.material.map = tex;

                    // âœ¨âœ¨âœ¨ã€å…³é”®ä¿®æ”¹ 2ã€‘âœ¨âœ¨âœ¨
                    // è¿™é‡Œä¹Ÿè¦æ”¹ï¼åŠ è½½å®Œå›¾ç‰‡åï¼Œå¿…é¡»æŠŠåº•è‰²æ”¹æˆç™½è‰²
                    frontMesh.material.color.set(0xffffff);

                    frontMesh.material.needsUpdate = true;
                },
                undefined,
                (err) => { console.log("å›¾ç‰‡åŠ è½½å¤±è´¥:", data.file); }
            );
        }
        function updateSlotUI(index, data, isRev) {
            const infoEl = document.getElementById(`info-${index}`);
            const nameEl = document.getElementById(`label-name-${index}`);
            const orientEl = document.getElementById(`label-orient-${index}`);
            const slotEl = document.getElementById(`slot-${index}`);
            nameEl.innerText = data.cn;
            orientEl.innerText = isRev ? "é€†ä½" : "æ­£ä½";
            orientEl.className = isRev ? "text-red-300 text-xs mt-1 px-2 py-0.5 rounded bg-black/50 inline-block border border-red-900" : "text-yellow-300 text-xs mt-1 px-2 py-0.5 rounded bg-black/50 inline-block border border-yellow-900";
            infoEl.style.opacity = 1;
            slotEl.style.borderColor = isRev ? 'rgba(239, 68, 68, 0.5)' : 'rgba(234, 179, 8, 0.5)';
        }

        function showInterpretation(data, isRev) {
            const panel = document.getElementById('interpretation-panel');
            const nameEl = document.getElementById('interp-name');
            const descEl = document.getElementById('interp-desc');
            nameEl.innerText = (isRev ? "â†“ " : "â†‘ ") + data.cn;
            nameEl.className = isRev ? "text-2xl font-bold text-red-300 mb-2 font-serif" : "text-2xl font-bold text-yellow-100 mb-2 font-serif";
            descEl.innerText = data.desc + (isRev ? "\n(é€†ä½ï¼šèƒ½é‡å—é˜»æˆ–å†…åœ¨è½¬åŒ–)" : "");
            panel.classList.add('visible');
        }

        function updateStatusUI() {
            const titleEl = document.getElementById('phase-title');
            const instructEl = document.getElementById('gesture-instruction');
            if (drawnCards.length < MAX_CARDS) {
                titleEl.innerText = `æ­£åœ¨æŠ½å–: ${PHASES[drawnCards.length]}`;
                titleEl.className = "text-sm font-bold text-yellow-100 mb-1";
                if (!hoveredCard) {
                    instructEl.innerHTML = '<span class="mr-2 text-base">ğŸ–</span> å·¦å³æ»‘åŠ¨æµè§ˆ Â· ç‚¹å‡»æŠ½å–';
                    instructEl.className = "text-xs text-white font-medium pulse-text flex items-center";
                } else {
                    instructEl.innerHTML = '<span class="mr-2 text-base">âš¡</span> ç‚¹å‡»ä»»æ„ä½ç½®æŠ½å–';
                    instructEl.className = "text-xs text-red-300 font-bold pulse-text flex items-center";
                }
            } else {
                titleEl.innerText = "âœ¨ å åœå®Œæˆ âœ¨";
                instructEl.innerHTML = "ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®è¿›è¡Œ AI è§£è¯»";
                titleEl.className = "text-sm font-bold text-green-300 mb-1";
                instructEl.className = "text-xs text-gray-300 font-light";
                document.getElementById('reset-btn').classList.remove('hidden');
                document.getElementById('change-q-btn').classList.remove('hidden');
                document.getElementById('ai-btn').classList.remove('hidden');
            }
        }

        // --- 3. æ ¸å¿ƒé€»è¾‘å‡½æ•° (å…¨éƒ¨æå‡) ---

        function handleScroll() {
            if (!isGameActive) return;
            if (animationQueue.length > 0 || drawnCards.length >= MAX_CARDS) return;
            if (gesture === 'OPEN' && !isDragging) {
                const offset = handPos.x - 0.5; 
                if (Math.abs(offset) > 0.05) scrollVelocity -= offset * CONFIG.scrollSpeed;
            } else if (gesture === 'POINT') scrollVelocity *= 0.8; 
            else if (gesture === 'FIST') scrollVelocity *= 0.2; 
            scrollVelocity *= CONFIG.dragInertia;
            currentAngle += scrollVelocity * 0.2; 
        }

        function updateCardLayout() {
            const time = Date.now() * 0.001;
            if (!deckGroup || !deckGroup.children) return;

            deckGroup.children.forEach(card => {
                if (card.userData.isDrawn) return; 
                let cardAngle = card.userData.angleOffset + currentAngle;
                const totalArc = CONFIG.cardCount * CONFIG.angleStep;
                while (cardAngle > totalArc / 2) cardAngle -= totalArc;
                while (cardAngle < -totalArc / 2) cardAngle += totalArc;
                const r = CONFIG.archRadius;
                const x = r * Math.sin(cardAngle);
                const y = r * Math.cos(cardAngle) + CONFIG.archY;
                const z = -Math.abs(cardAngle) * 5; 
                const isVisible = Math.abs(cardAngle) < 1.0; 
                card.visible = isVisible;
                if (isVisible) {
                    card.position.set(x, y, z);
                    card.lookAt(0, -10, -r); 
                    let scale = 1;
                    let zOffset = 0;
                    if (card === hoveredCard) { scale = 1.15; zOffset = 2.0; }
                    card.scale.setScalar(THREE.MathUtils.lerp(card.scale.x, scale, 0.1));
                    card.position.z += zOffset;
                    card.position.y += zOffset * 0.2;
                }
            });
        }

        function updateDrawnCards() {
            drawnCards.forEach((card, idx) => {
                if (animationQueue.includes(card)) return;
                const targetPos = getSlotWorldPosition(idx);
                card.position.x = THREE.MathUtils.lerp(card.position.x, targetPos.x, 0.1);
                card.position.y = THREE.MathUtils.lerp(card.position.y, targetPos.y, 0.1);
                card.position.z = THREE.MathUtils.lerp(card.position.z, 0, 0.1);
                const targetQuat = camera.quaternion.clone();
                if (card.userData.isReversed) {
                    const rotZ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI);
                    targetQuat.multiply(rotZ);
                }
                card.quaternion.copy(targetQuat); 
                card.scale.setScalar(THREE.MathUtils.lerp(card.scale.x, CONFIG.slotScale, 0.1));
            });
        }

        function updateRaycaster() {
            if (!isGameActive) return;
            if (animationQueue.length > 0) return;
            const ndc = new THREE.Vector2(handPos.x * 2 - 1, -(handPos.y * 2 - 1));
            raycaster.setFromCamera(ndc, camera);
            if (drawnCards.length >= MAX_CARDS) return;
            if (!deckGroup) return;
            const intersects = raycaster.intersectObjects(deckGroup.children, true);
            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && target.parent !== deckGroup) { target = target.parent; }
                if (!target.userData.isDrawn) {
                    const prevHover = hoveredCard;
                    hoveredCard = target;
                    ensureCardTexture(hoveredCard);
                    if (prevHover !== hoveredCard) updateStatusUI(); 
                }
            } else {
                if (hoveredCard) { hoveredCard = null; updateStatusUI(); }
            }
        }

        function phase2(card, index) {
            const targetPos = getSlotWorldPosition(index);
            const startPos = card.position.clone();
            const startScale = card.scale.x;
            let progress = 0;
            document.getElementById('interpretation-panel').classList.remove('visible');
            function animateDrop() {
                progress += 0.04;
                const t = Math.min(progress, 1);
                const ease = t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                card.position.lerpVectors(startPos, targetPos, ease);
                const targetQuat = camera.quaternion.clone();
                if (card.userData.isReversed) {
                    const rotZ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI);
                    targetQuat.multiply(rotZ);
                }
                card.quaternion.slerp(targetQuat, 0.1); 
                card.scale.setScalar(THREE.MathUtils.lerp(startScale, CONFIG.slotScale, ease));
                if (t < 1) requestAnimationFrame(animateDrop); else {
                    const idx = animationQueue.indexOf(card);
                    if (idx > -1) animationQueue.splice(idx, 1);
                    updateSlotUI(index, card.userData.data, card.userData.isReversed);
                }
            }
            animateDrop();
        }

        function confirmSelection(card) {
            if (!card) return;
            card.userData.isDrawn = true;
            animationQueue.push(card);
            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            card.getWorldPosition(worldPos);
            card.getWorldQuaternion(worldQuat);
            scene.add(card);
            card.position.copy(worldPos);
            card.quaternion.copy(worldQuat);
            ensureCardTexture(card);
            const centerPos = new THREE.Vector3(0, 0.5, CONFIG.camZ - 7);
            const slotIndex = drawnCards.length;
            drawnCards.push(card); 
            updateStatusUI();
            const targetRotY = 0; 
            const targetRotZ = card.userData.isReversed ? Math.PI : 0;
            const startPos = card.position.clone();
            const startRot = card.rotation.clone();
            let progress = 0;
            showInterpretation(card.userData.data, card.userData.isReversed);
            function phase1() {
                progress += 0.025;
                const t = Math.min(progress, 1);
                const ease = 1 - Math.pow(1 - t, 3);
                card.position.lerpVectors(startPos, centerPos, ease);
                card.rotation.x = THREE.MathUtils.lerp(startRot.x, 0, ease);
                card.rotation.y = THREE.MathUtils.lerp(startRot.y, targetRotY, ease);
                card.rotation.z = THREE.MathUtils.lerp(startRot.z, targetRotZ, ease);
                card.scale.setScalar(THREE.MathUtils.lerp(1, 0.85, ease)); 
                if (t < 1) requestAnimationFrame(phase1); else setTimeout(() => phase2(card, slotIndex), 1500); 
            }
            phase1();
        }

        function handleGestureState(newGesture) {
            if (!isGameActive) return;
            if (gesture === newGesture) return;
            gesture = newGesture;
            updateCursorStyle('GESTURE');
            if (drawnCards.length < MAX_CARDS && animationQueue.length === 0) {
                if (gesture === 'FIST' && hoveredCard) confirmSelection(hoveredCard);
            }
        }

        function analyzeGesture(lm) { 
            if (!isGameActive) return; 
            if (isDragging) return;

            const tipIndex=lm[8]; const tipThumb=lm[4]; const tipMiddle=lm[12]; const tipRing=lm[16]; const tipPinky=lm[20]; const wrist=lm[0]; const rawX=1-tipIndex.x; const rawY=tipIndex.y; handPos.x+=(rawX-handPos.x)*0.4; handPos.y+=(rawY-handPos.y)*0.4; const el=document.getElementById('cursor'); el.style.display='block'; el.style.left=handPos.x*window.innerWidth+'px'; el.style.top=handPos.y*window.innerHeight+'px'; const dWrist=(pt)=>Math.hypot(pt.x-wrist.x,pt.y-wrist.y); const fingerExtended=[dWrist(tipThumb)>0.15, dWrist(tipIndex)>0.2, dWrist(tipMiddle)>0.2, dWrist(tipRing)>0.2, dWrist(tipPinky)>0.2]; const pinchDist=Math.hypot(tipIndex.x-tipThumb.x,tipIndex.y-tipThumb.y); let detected='OPEN'; const fingersFolded=!fingerExtended[1]&&!fingerExtended[2]&&!fingerExtended[3]&&!fingerExtended[4]; if(pinchDist<0.05) detected='PINCH'; else if(fingersFolded) detected='FIST'; else if(fingerExtended[1]&&!fingerExtended[2]&&!fingerExtended[3]) detected='POINT'; 
            
            handleGestureState(detected); 
        }

        // --- 4. ç»‘å®šä¸äº‹ä»¶ ---
        function resetAll() {
            drawnCards.forEach(card => scene.remove(card));
            drawnCards = [];
            createDeck();
            document.getElementById('reset-btn').classList.add('hidden');
            document.getElementById('change-q-btn').classList.add('hidden');
            document.getElementById('ai-btn').classList.add('hidden');
            for(let i=0; i<3; i++) {
                document.getElementById(`info-${i}`).style.opacity = 0;
                document.getElementById(`slot-${i}`).style.borderColor = 'rgba(168, 85, 247, 0.4)';
            }
            document.getElementById('interpretation-panel').classList.remove('visible');
            updateStatusUI();
        }

        function enterGame() {
            const input = document.getElementById('question-input');
            userQuestion = input.value.trim() || "æˆ‘çš„è¿‘æœŸç»¼åˆè¿åŠ¿å¦‚ä½•ï¼Ÿ";
            document.getElementById('start-screen').style.opacity = '0';
            const mainUi = document.getElementById('main-ui');
            mainUi.style.display = 'flex';
            void mainUi.offsetWidth; mainUi.style.opacity = '1';
            document.getElementById('user-question-display').innerText = userQuestion;
            isGameActive = true; 
            updateStatusUI();
            // âœ¨âœ¨âœ¨ æ–°å¢ï¼šè¿›å…¥æ¸¸æˆç«‹åˆ»å¼€å§‹åŠ è½½æ‰€æœ‰å›¾ç‰‡ âœ¨âœ¨âœ¨
            preloadAllImages();
            startCamera();
            setTimeout(() => { document.getElementById('start-screen').style.display = 'none'; }, 1000);
        }

        function changeQuestion() {
            resetAll();
            isGameActive = false;
            document.getElementById('main-ui').style.opacity = '0';
            const startScreen = document.getElementById('start-screen');
            startScreen.style.display = 'flex';
            void startScreen.offsetWidth;
            startScreen.style.opacity = '1';
            setTimeout(() => { document.getElementById('main-ui').style.display = 'none'; }, 800);
        }

        function handleImageUpload(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            alert(`æ­£åœ¨è¯»å– ${files.length} å¼ å›¾ç‰‡ï¼Œè¯·ç¨å€™...`);
            Promise.all(files.map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve({ name: file.name.toLowerCase(), src: e.target.result });
                    reader.readAsDataURL(file);
                });
            })).then(images => {
                customImages = images;
                alert("è¯»å–å®Œæˆï¼ç‚¹å‡»ã€ğŸ’¾ å¯¼å‡ºç¦»çº¿ç‰ˆã€‘å³å¯ç”ŸæˆåŒ…å«å›¾ç‰‡çš„æ°¸ä¹…æ–‡ä»¶ã€‚");
                document.getElementById('export-btn').classList.remove('hidden');
            });
        }

        function exportHTML() {
            if (customImages.length === 0) { alert("è¯·å…ˆå¯¼å…¥å›¾ç‰‡ï¼"); return; }
            const btn = document.getElementById('export-btn');
            btn.innerText = "æ‰“åŒ…ä¸­...";
            setTimeout(() => {
                let html = document.documentElement.outerHTML;
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                doc.getElementById('canvas-container').innerHTML = '';
                const exportBtn = doc.getElementById('export-btn'); if(exportBtn) exportBtn.style.display = 'none'; 
                const importBtn = doc.getElementById('btn-import'); if(importBtn) importBtn.style.display = 'none';
                doc.getElementById('start-screen').style.opacity = '1';
                doc.getElementById('start-screen').style.display = 'flex';
                doc.getElementById('main-ui').style.display = 'none';
                let dataScript = `\n<script>\nwindow.TAROT_IMAGES = {\n`;
                customImages.forEach(img => { dataScript += `    "${img.name}": "${img.src}",\n`; });
                dataScript += `};\n<\/script>\n`;
                let cleanHTML = doc.documentElement.outerHTML;
                cleanHTML = cleanHTML.replace('</head>', dataScript + '</head>');
                const blob = new Blob(['<!DOCTYPE html>\n' + cleanHTML], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'tarot_pro_offline.html';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                btn.innerText = "ğŸ’¾ å¯¼å‡ºç¦»çº¿ç‰ˆ";
                alert("âœ… æ‰“åŒ…å®Œæˆï¼");
            }, 200);
        }

        function saveSettings() {
            const key = document.getElementById('api-key-input').value;
            const url = document.getElementById('api-url-input').value;
            const model = document.getElementById('api-model-input').value;
            localStorage.setItem('gemini_api_key', key);
            localStorage.setItem('gemini_api_url', url);
            localStorage.setItem('gemini_api_model', model);
            document.getElementById('settings-modal').style.display = 'none';
            alert("è®¾ç½®å·²ä¿å­˜ï¼");
        }
        
        function closeAiModal() { document.getElementById('ai-modal').style.display = 'none'; isGameActive = true; }
        function openSettings() { document.getElementById('settings-modal').style.display = 'flex'; }

        async function startAIReading() {
            isGameActive = false;
            const modal = document.getElementById('ai-modal');
            const content = document.getElementById('ai-content');
            modal.style.display = 'flex';
            
            // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            content.innerHTML = `<div class="flex flex-col items-center justify-center h-40 space-y-4"><div class="w-8 h-8 border-4 border-purple-500 border-t-transparent rounded-full animate-spin"></div><p class="text-purple-200 text-sm animate-pulse">æ­£åœ¨è¿æ¥çµç•Œ...</p></div>`;
            
            // 1. å‡†å¤‡å¡ç‰Œæ•°æ®
            let cardsStr = "";
            drawnCards.forEach((card, idx) => {
                const data = card.userData.data;
                const pos = PHASES[idx];
                const orient = card.userData.isReversed ? "é€†ä½" : "æ­£ä½";
                cardsStr += `${idx + 1}. ${pos}: ${data.cn} (${data.en}) - ${orient}\n`;
            });

            // âœ¨âœ¨âœ¨ é‡ç‚¹ï¼šå®Œå…¨æ¢å¤äº†ä½ æƒ³è¦çš„â€œé«˜çµæ€§â€äººè®¾ âœ¨âœ¨âœ¨
            const systemPrompt = `ä½ ä¸æ˜¯åœ¨è§£é‡Šå¡”ç½—ç‰Œä¹‰ï¼Œä½ æ­£åœ¨ä¸ºä¸€ä¸ªçœŸå®çš„äººè¿›è¡Œå åœã€‚

ä½ çš„èº«ä»½æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œã€ç›´è§‰æå¼ºçš„å¡”ç½—å¸ˆï¼š
- ä½ ç›¸ä¿¡ç‰Œä¸æ˜¯éšæœºçš„ï¼Œè€Œæ˜¯å›åº”æé—®è€…çš„æ½œæ„è¯†
- ä½ ä¼šä¼˜å…ˆè¯´å‡ºâ€œæœ€é‡è¦ã€æœ€åˆºç—›ã€æœ€è¢«å›é¿çš„é‚£ä¸€ç‚¹â€
- ä½ å…è®¸ä½¿ç”¨ç›´è§‰åˆ¤æ–­ï¼Œè€Œä¸æ˜¯å®Œå…¨ä¾èµ–æ•™ç§‘ä¹¦ç‰Œä¹‰

å åœé£æ ¼è¦æ±‚ï¼š
- è¯­è¨€è¦æœ‰æ¸©åº¦ï¼Œåƒåœ¨ä½å£°å¯¹è¯ï¼Œè€Œä¸æ˜¯å†™æŠ¥å‘Š
- ä¸è¦æŒ‰â€œæ¯å¼ ç‰Œåˆ†åˆ«è§£é‡Šâ€çš„æ•™ç§‘ä¹¦ç»“æ„
- å¯ä»¥åœ¨è§£è¯»ä¸­åœé¡¿ã€åé—®ã€ç›´æŒ‡æƒ…ç»ª
- å…è®¸æ¨¡ç³Šæ€§ã€è±¡å¾æ€§å’Œå¿ƒç†æš—ç¤º
- å°‘æ€»ç»“ï¼Œå¤šæ­ç¤º

ä½ çš„ç›®æ ‡ä¸æ˜¯å®‰æ…°äººï¼Œè€Œæ˜¯å¸®åŠ©æé—®è€…çœ‹æ¸…æ­£åœ¨å‘ç”Ÿçš„äº‹ã€‚`;

            // âœ¨âœ¨âœ¨ é‡ç‚¹ï¼šå®Œå…¨æ¢å¤äº†ç”¨æˆ·å¼•å¯¼è¯ âœ¨âœ¨âœ¨
            const userPrompt = `æˆ‘ç°åœ¨çš„é—®é¢˜æ˜¯ï¼šã€Œ${userQuestion}ã€ã€‚

åœ¨å¼€å§‹è§£è¯»å‰ï¼Œè¯·ä½ å…ˆé™é»˜ç‰‡åˆ»ï¼ŒåƒçœŸæ­£çš„å¡”ç½—å¸ˆä¸€æ ·æ„Ÿå—è¿™ç»„ç‰Œçš„æ•´ä½“æ°”æ¯ã€‚

æˆ‘æŠ½åˆ°çš„ä¸‰å¼ ç‰Œï¼ˆæŒ‰æ—¶é—´é¡ºåºå±•å¼€ï¼‰æ˜¯ï¼š
${cardsStr}

è¯·åƒçœŸæ­£çš„å¡”ç½—å¸ˆä¸€æ ·ï¼Œå…ˆé™é™æ„Ÿå—è¿™ç»„ç‰Œçš„æ•´ä½“æ°”æ¯ã€‚
æ ¹æ®ç‰Œé˜µçš„æ°”è´¨å’Œæ´—ç‰Œæ—¶çš„å‘½è¿èƒ½é‡ï¼Œè¯·è‡ªåŠ¨é€‰æ‹©é€‚åˆçš„è§£è¯»é£æ ¼ï¼ˆæ¸©æŸ”/å†·é™/æ®‹é…·ï¼‰ï¼Œè®©è§£è¯»æ—¢æœ‰çµé­‚ï¼Œåˆèƒ½ç›´å‡»æˆ‘çš„å†…å¿ƒã€‚

ä¸è¦æœºæ¢°åˆ—å‡ºç‰Œä¹‰ï¼Œè€Œæ˜¯ï¼š
- ä»ç›´è§‰å‡ºå‘è®²è¿°ç‰Œçš„æ•…äº‹
- ç”¨æ¯”å–»ã€æ„è±¡å’Œæƒ…ç»ªå»è¡¨è¾¾
- è®©æ¯å¼ ç‰Œéƒ½æœ‰å®ƒç‹¬ç‰¹çš„å£°éŸ³

è¯·å¼€å§‹ä½ çš„è¯¦ç»†è§£è¯»ã€‚`;

            // 2. è·å– API é…ç½®
            const apiKey = localStorage.getItem('gemini_api_key') || DEFAULT_API_KEY;
            let baseUrl = localStorage.getItem('gemini_api_url') || 'https://api.siliconflow.cn/v1';
            let model = localStorage.getItem('gemini_api_model') || 'deepseek-ai/DeepSeek-V3';

            if (!apiKey) {
                content.innerHTML = `<p class="text-red-300 text-center p-4">âš ï¸ é”™è¯¯ï¼šæœªæ£€æµ‹åˆ° API Key</p>`;
                return;
            }

            try {
                const cleanBaseUrl = baseUrl.replace(/\/$/, '');
                let url = "";
                let body = {};
                let headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };

                // ======= ğŸ§  æ™ºèƒ½é€»è¾‘ (å…¼å®¹ DeepSeek) =======
                
                if (cleanBaseUrl.includes('goog') && cleanBaseUrl.includes('generativelanguage')) {
                    // Google åŸç”Ÿæ¨¡å¼
                    url = `${cleanBaseUrl}/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                    delete headers['Authorization']; 
                    const combinedText = systemPrompt + "\n\n---\n\n" + userPrompt;
                    body = { contents: [{ parts: [{ text: combinedText }] }] };
                } else {
                    // OpenAI æ ‡å‡†æ¨¡å¼ (SiliconFlow / DeepSeek)
                    if (cleanBaseUrl.includes('chat/completions')) {
                        url = cleanBaseUrl;
                    } else {
                        url = `${cleanBaseUrl}/chat/completions`;
                    }

                    body = {
                        model: model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: userPrompt }
                        ],
                        stream: false
                    };
                }

                console.log("æ­£åœ¨è¯·æ±‚:", url); 

                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    const errText = await response.text();
                    throw new Error(`API è¯·æ±‚å¤±è´¥ (${response.status}): ${errText.slice(0, 100)}`);
                }

                const data = await response.json();
                let text = "";

                if (data.choices && data.choices[0] && data.choices[0].message) {
                    text = data.choices[0].message.content;
                } else if (data.candidates && data.candidates[0].content) {
                    text = data.candidates[0].content.parts[0].text;
                } else {
                    text = "è§£è¯»å¤±è´¥ï¼šè¿”å›æ•°æ®æ ¼å¼æ— æ³•è¯†åˆ«ã€‚";
                }
                
                content.innerHTML = marked.parse(text);

            } catch (err) {
                console.error(err);
                content.innerHTML = `
                    <div class="text-red-300 text-center p-4">
                        <p class="font-bold mb-2">ğŸ”® è¿æ¥ä¸­æ–­</p>
                        <p class="text-xs text-gray-400 bg-black/50 p-2 rounded break-all font-mono">${err.message}</p>
                    </div>`;
            }
        };

        async function startCamera() { 
            const video = document.querySelector('.input_video'); 
            const canvas = document.querySelector('.camera-preview'); 
            const ctx = canvas.getContext('2d'); 
            const btn = document.getElementById('cam-btn'); 
            
            if (cameraStream) {
                 const tracks = cameraStream.getTracks();
                 if(tracks.length > 0 && tracks[0].readyState === 'live') return; 
            }

            btn.innerText = "å¯åŠ¨ä¸­..."; 
            
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            try { 
                const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`}); 
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6}); 
                hands.onResults(results => { 
                    ctx.save(); 
                    ctx.clearRect(0, 0, canvas.width, canvas.height); 
                    if(results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height); 
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) { 
                        const lm = results.multiHandLandmarks[0]; 
                        drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2}); 
                        drawLandmarks(ctx, lm, {color: '#FF0000', lineWidth: 1}); 
                        analyzeGesture(lm); // ç›´æ¥è°ƒç”¨
                    } 
                    ctx.restore(); 
                }); 
                const camera = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 }); 
                await camera.start(); 
                cameraStream = video.srcObject;
                btn.style.display = 'none'; 
                canvas.style.display = 'block'; 
            } catch(e) { 
                console.error(e); 
                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    btn.innerText = "âš ï¸ æƒé™è¢«æ‹’";
                    alert("âš ï¸ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥\n\næ‚¨ä¼¼ä¹æ‹’ç»äº†æ‘„åƒå¤´æƒé™ã€‚\n\nè¯·ç‚¹å‡»æµè§ˆå™¨åœ°å€æ å·¦ä¾§çš„ã€é”å½¢å›¾æ ‡ã€‘æˆ–ã€è®¾ç½®ã€‘ï¼Œå…è®¸æ‘„åƒå¤´æƒé™ååˆ·æ–°é¡µé¢ã€‚\n\næˆ–è€…ï¼Œæ‚¨ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ã€é¼ æ ‡/è§¦å±ã€‘æ¨¡å¼ï¼š\nğŸ– æ‹–æ‹½å±å¹• = æµè§ˆç‰Œé˜µ\nğŸ‘† ç‚¹å‡»å¡ç‰Œ = ç›´æ¥æŠ½å–");
                } else if (e.name === 'NotReadableError' || e.name === 'TrackStartError') {
                    btn.innerText = "âš ï¸ è®¾å¤‡å ç”¨";
                    alert("âš ï¸ æ‘„åƒå¤´è¢«å ç”¨\n\nè¯·æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–ç½‘é¡µï¼ˆå¦‚ Zoomã€è…¾è®¯ä¼šè®®ï¼‰æ­£åœ¨ä½¿ç”¨æ‘„åƒå¤´ã€‚\n\næ‚¨ä¾ç„¶å¯ä»¥ä½¿ç”¨ã€é¼ æ ‡/è§¦å±ã€‘æ¨¡å¼è¿›è¡Œæ¸¸æˆã€‚");
                } else {
                    btn.innerText = "å¯åŠ¨å¤±è´¥";
                }
            } 
        };

        function createDeck() {
            if(deckGroup) scene.remove(deckGroup);
            deckGroup = new THREE.Group();
            scene.add(deckGroup);
            const geo = new THREE.PlaneGeometry(CONFIG.cardW, CONFIG.cardH);
            const borderGeo = new THREE.PlaneGeometry(CONFIG.cardW + 0.1, CONFIG.cardH + 0.1);
            const backMat = new THREE.MeshStandardMaterial({ map: cardBackTexture, roughness: 0.6, metalness: 0.1, color: 0xffffff });
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xc084fc }); 
            const frontMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            shuffleArray(DECK_DATA);
            DECK_DATA.forEach((data, i) => {
                const card = new THREE.Group();
                const back = new THREE.Mesh(geo, backMat);
                back.rotation.y = Math.PI; back.position.z = -0.01;   
                const front = new THREE.Mesh(geo, frontMat.clone());
                front.rotation.y = 0; front.position.z = 0.01;   
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = 0;
                card.add(back, front, border);
                card.userData = { id: i, data: data, angleOffset: i * CONFIG.angleStep, isReversed: Math.random() < 0.3, isDrawn: false };
                deckGroup.add(card);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if(stars) stars.rotation.z += 0.0001;
            handleScroll();
            updateRaycaster();
            updateCardLayout();
            updateDrawnCards(); 
            renderer.render(scene, camera);
        }

        function setupPointerEvents() {
            const container = document.getElementById('canvas-container');
            container.addEventListener('pointerdown', (e) => {
                if (!isGameActive) return;
                isDragging = true;
                pointerStartX = e.clientX;
                pointerStartTime = Date.now();
                scrollVelocity = 0; 
            });
            container.addEventListener('pointermove', (e) => {
                if (!isGameActive) return;
                handPos.x = e.clientX / window.innerWidth;
                handPos.y = e.clientY / window.innerHeight;
                const el = document.getElementById('cursor');
                el.style.left = e.clientX + 'px';
                el.style.top = e.clientY + 'px';
                updateCursorStyle('POINTER');
                if (isDragging) {
                    const deltaX = e.clientX - pointerStartX;
                    pointerStartX = e.clientX;
                    scrollVelocity += deltaX * 0.0005; 
                }
            });
            container.addEventListener('pointerup', (e) => {
                if (!isGameActive) return;
                isDragging = false;
                const duration = Date.now() - pointerStartTime;
                const dist = Math.abs(e.clientX - pointerStartX);
                if (duration < 500 && dist < 30) {
                    const ndc = new THREE.Vector2(e.clientX/window.innerWidth * 2 -1, -(e.clientY/window.innerHeight * 2 -1));
                    raycaster.setFromCamera(ndc, camera);
                    if (drawnCards.length < MAX_CARDS) {
                        const intersects = raycaster.intersectObjects(deckGroup.children, true);
                        if (intersects.length > 0) {
                            let target = intersects[0].object;
                            while(target.parent && target.parent !== deckGroup) { target = target.parent; }
                            if (!target.userData.isDrawn) {
                                confirmSelection(target);
                            }
                        }
                    }
                }
            });
        }

        function init() {
            try {
                document.getElementById('start-btn').addEventListener('click', enterGame);
                document.getElementById('settings-btn').addEventListener('click', openSettings);
                document.getElementById('save-settings-btn').addEventListener('click', saveSettings);
                document.getElementById('cancel-settings-btn').addEventListener('click', () => document.getElementById('settings-modal').style.display = 'none');
                document.getElementById('cam-btn').addEventListener('click', startCamera);
                document.getElementById('upload-input').addEventListener('change', handleImageUpload);
                document.getElementById('export-btn').addEventListener('click', exportHTML);
                document.getElementById('reset-btn').addEventListener('click', resetAll);
                document.getElementById('change-q-btn').addEventListener('click', changeQuestion);
                document.getElementById('ai-btn').addEventListener('click', startAIReading);
                document.getElementById('close-ai-btn').addEventListener('click', closeAiModal);
                document.getElementById('close-ai-btn-2').addEventListener('click', closeAiModal);

                cardBackTexture = createBackPattern();
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050505, 0.02);
                camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 0, CONFIG.camZ);
                camera.lookAt(0, -1, 0); 

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                const ambient = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffd700, 1.2);
                dirLight.position.set(5, 10, 10);
                scene.add(dirLight);
                const pointLight = new THREE.PointLight(0x8b5cf6, 1.5, 20);
                pointLight.position.set(0, -5, 5);
                scene.add(pointLight);

                createStars();
                
                deckGroup = new THREE.Group();
                scene.add(deckGroup);
                createDeck();
                
                raycaster = new THREE.Raycaster();

                window.addEventListener('resize', onResize);
                setupPointerEvents();
                
                const savedKey = localStorage.getItem('gemini_api_key');
                if(savedKey) document.getElementById('api-key-input').value = savedKey;
                const savedUrl = localStorage.getItem('gemini_api_url');
                if(savedUrl) document.getElementById('api-url-input').value = savedUrl;
                const savedModel = localStorage.getItem('gemini_api_model');
                if(savedModel) document.getElementById('api-model-input').value = savedModel;
                
            } catch (e) {
                console.error(e);
                alert("åˆå§‹åŒ–å¤±è´¥: " + e.message);
            }
        }

        window.onload = function() {
            init();
            animate();
            onResize();
        };
    </script>
</body>
</html>